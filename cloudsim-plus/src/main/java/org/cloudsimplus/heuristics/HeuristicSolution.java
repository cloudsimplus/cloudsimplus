/*
 * CloudSim Plus: A modern, highly-extensible and easier-to-use Framework for
 * Modeling and Simulation of Cloud Computing Infrastructures and Services.
 * http://cloudsimplus.org
 *
 *     Copyright (C) 2015-2018 Universidade da Beira Interior (UBI, Portugal) and
 *     the Instituto Federal de Educação Ciência e Tecnologia do Tocantins (IFTO, Brazil).
 *
 *     This file is part of CloudSim Plus.
 *
 *     CloudSim Plus is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     CloudSim Plus is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with CloudSim Plus. If not, see <http://www.gnu.org/licenses/>.
 */
package org.cloudsimplus.heuristics;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A solution for a complex problem found using a {@link Heuristic} implementation.
 * A heuristic can generate multiple solutions until find an optimal or suboptimal
 * solution for the problem.
 *
 * @author Manoel Campos da Silva Filho
 * @param <T> the type used to store the result of the solution.
 * Check {@link #getResult()} for more details.
 * @since CloudSim Plus 1.0
 */
public interface HeuristicSolution<T> extends Comparable<HeuristicSolution<T>> {
    Logger LOGGER = LoggerFactory.getLogger(HeuristicSolution.class.getSimpleName());

    /**
     * An attribute that implements the Null Object Design Pattern for {@link HeuristicSolution}
     * objects.
     */
    HeuristicSolution NULL = new HeuristicSolutionNull();

	/**
	 * @return the heuristic that generated this solution.
	 */
	Heuristic<HeuristicSolution<T>> getHeuristic();

    /**
     * Defines how good the solution is and it the inverse of the {@link #getCost()}.
     * As higher is the fitness,
     * better is a solution. How a solution fitness is computed is totally
     * dependent of the heuristic implementation being used
     * to find a solution.
     *
     * @return the solution fitness
     * @see #getCost()
     */
    default double getFitness() {
        return 1.0/getCost();
    }

    /**
     * Defines the cost of using this solution.
     * As higher is the cost, worse is a solution. How a solution cost is computed is totally
     * dependent of the heuristic implementation being used to find a solution.
     *
     * @return the solution cost
     * @see #getFitness()
     */
    double getCost();

    /**
     * Gets the result of the solution.
     * For instance, if a implementation of this interface aims to provide
     * a mapping between Cloudlets and Vm's, this type would be
     * a {@code  Map<Cloudlet, Vm>}, that will indicate which Vm will
     * run each Cloudlet.
     * This way, the type T of the solution is totally dependent of the problem
     * being solved by the heuristic implementation.
     *
     * <p>
     * The result of solution is generated by a heuristic.
     * Getting an optimal or sub-optimal solution is the final goal of a heuristic.
     * </p>
     *
     * @return the object containing the result of the generated solution.
     */
    T getResult();
}
